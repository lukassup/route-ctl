# -*- coding: utf-8 -*-
"""route-ctl output printer."""

from __future__ import (
    absolute_import,
    print_function,
    unicode_literals,
    with_statement,
)

import tempfile
import string
import os

try:
    unicode
    basestring
except NameError:
    # NOTE: PY2 compat
    unicode = basestring = str

HEADER = '''\
##
#   This file was automatically generated by route-ctl
#

class netroutes::routes {
'''

FOOTER = '''\
}
'''

TEMPLATE = '''\
  network_route {{ {name}:
    ensure    => {ensure},
    gateway   => {gateway},
    interface => {interface},
    netmask   => {netmask},
    network   => {network},
    options   => {options},
  }}
'''


class RouteFormatter(string.Formatter):
    """Silently skips missing values by inserting empty strings and formats
    literals prefixed by a token.
    """

    def __init__(self, missing='', var='$'):
        """Optionally initialized with a ``missing`` placeholder string."""
        self.missing = repr(missing)
        self.var = var

    def get_field(self, field_name, args, kwargs):
        """Quietly return ``None`` for missing keys and attributes."""
        try:
            value, field = super(RouteFormatter, self).get_field(
                field_name, args, kwargs)
        except (KeyError, AttributeError):
            return None, field_name
        # NOTE: PY2 compatibility. This should reliably quote both Unicode and
        # non-Unicode strings in Python 2 and 3.
        if isinstance(value, basestring) and not value.startswith(self.var):
            value = repr(str(value))
        return value, field

    def format_field(self, value, format_spec):
        """Insert the ``missing`` placeholder if value is ``false``-like."""
        if value is None:
            value = self.missing
        return super(RouteFormatter, self).format_field(value, format_spec)


class RouteBuilder(object):
    """Route output file builder."""

    def __init__(self,
                 template=TEMPLATE,
                 header=HEADER,
                 footer=FOOTER,
                 formatter=RouteFormatter):
        self._template = template
        self._header = header
        self._footer = footer
        self._formatter = formatter()

    def build(self, routes):
        """Iteratively build the output."""
        if self._header:
            yield self._header
        for route in routes:
            yield self._formatter.format(self._template, **route)
        if self._footer:
            yield self._footer

    def _write(self, routes, dest_file):
        """Write formatted routes to file (low-level implementation)."""
        with dest_file:
            for lines in self.build(routes):
                dest_file.writelines(lines)

    @staticmethod
    def rotate_backups(base_filename, pattern='%s.%d', backups=5):
        """Backup file rotator. Keeps five ``backups`` by default.

        Taken from the ``logging`` module in Python standard library.
        """
        if backups > 0:
            for i in range(backups - 1, 0, -1):
                sfn = pattern % (base_filename, i)
                dfn = pattern % (base_filename, i + 1)
                if os.path.exists(sfn):
                    if os.path.exists(dfn):
                        os.remove(dfn)
                    os.rename(sfn, dfn)
            dfn = pattern % (base_filename, 1)
            if os.path.exists(dfn):
                os.remove(dfn)
            if os.path.exists(base_filename):
                os.rename(base_filename, dfn)

    def write(self, routes, dest_filename, atomic=True, backups=5):
        """Safely write formatted routes to file.

        ``atomic`` operation writes the output to a temporary file and moves it over the original.

        non-``atomic`` operation modifies the original file in place.
        """
        self.rotate_backups(dest_filename, backups=backups)
        if atomic:
            _file = tempfile.NamedTemporaryFile(mode='w', delete=False)
        else:
            _file = open(dest_filename, 'w')
        self._write(routes, _file)
        if atomic:
            os.rename(_file.name, dest_filename)
