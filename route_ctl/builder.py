# -*- coding: utf-8 -*-
"""route-ctl output formatting, building and writing."""

from __future__ import (
    absolute_import,
    print_function,
    unicode_literals,
    with_statement,
)

import shutil
import string
import tempfile
from gettext import translation
from datetime import datetime
from logging import getLogger

try:
    unicode
    basestring
except NameError:
    # NOTE: PY2 compat
    unicode = basestring = str

# l18n
_ = translation(__name__, 'locale', fallback=True).gettext

HEADER = '''\
##
#   This file was automatically generated by route-ctl
#

class netroutes::routes {
'''

TEMPLATE = '''\
  network_route {{ {name}:
    ensure    => {ensure},
    gateway   => {gateway},
    interface => {interface},
    netmask   => {netmask},
    network   => {network},
    options   => {options},
  }}
'''

FOOTER = '''\
}
'''


class RouteFormatter(string.Formatter):
    """Silently skips missing values by inserting empty strings and formats
    literals prefixed by a token.
    """

    def __init__(self, missing='', var='$'):
        """Optionally initialized with a ``missing`` placeholder string."""
        self.missing = repr(missing)
        self.var = var

    def get_field(self, field_name, args, kwargs):
        """Quietly return ``None`` for missing keys and attributes."""
        try:
            value, field = super(RouteFormatter, self).get_field(
                field_name, args, kwargs)
        except (KeyError, AttributeError):
            return None, field_name
        # NOTE: PY2 compat: this should reliably quote both Unicode and
        # non-Unicode strings in Python 2 and 3.
        if isinstance(value, basestring) and not value.startswith(self.var):
            value = repr(str(value))
        return value, field

    def format_field(self, value, format_spec):
        """Insert the ``missing`` placeholder if value is ``False``-like."""
        if value is None:
            value = self.missing
        return super(RouteFormatter, self).format_field(value, format_spec)


class RouteBuilder(object):
    """Route output file builder."""

    def __init__(self,
                 filename=None,
                 template=TEMPLATE,
                 header=HEADER,
                 footer=FOOTER,
                 formatter=RouteFormatter):
        self.filename = filename
        self.__template = template
        self.__header = header
        self.__footer = footer
        self.__formatter = formatter()
        self.__log = getLogger(__name__)

    def __build(self, items):
        """Iteratively build the output."""
        if self.__header:
            yield self.__header
        for item in items:
            yield self.__formatter.format(self.__template, **item)
        if self.__footer:
            yield self.__footer

    def backup(self, stamp='%F_%H%M%S', copy=shutil.copy2):
        """Create timestamped backup files."""
        tstamp = datetime.now().strftime(stamp)
        sfn = self.filename
        dfn = '{0}.{1}.backup'.format(self.filename, tstamp)
        copy(sfn, dfn)

    def __write(self, items, dest_file):
        """Write formatted routes to file (low-level implementation)."""
        with dest_file:
            for lines in self.__build(items):
                dest_file.writelines(lines)

    def write(self, items, atomic=True, move=shutil.move):
        """Safely write formatted routes to file.

        ``atomic`` operation writes the output to a temporary file and moves it over the original.

        Non-``atomic`` operation modifies the original file in place.
        """
        self.__log.debug(_('Creating backup file'))
        self.backup()
        if atomic:
            self.__log.debug(_('Opening a temporary file for writing (atomic operation)'))
            file_ = tempfile.NamedTemporaryFile(mode='w', delete=False)
        else:
            self.__log.debug(_('Overwriting file in place (non-atomic operation)'))
            file_ = open(self.filename, 'w')
        self.__log.info(_('Writing entries to file'))
        self.__write(items, dest_file=file_)
        if atomic:
            self.__log.debug(_('Moving temporary file over the original'))
            move(file_.name, self.filename)
